大規模言語モデル（だいきぼげんごモデル、英: large language model、LLM）は、多数のパラメータ（数千万から数十億）を持つ人工ニューラルネットワークで構成されるコンピュータ言語モデルで、膨大なラベルなしテキストを使用して自己教師あり学習または半教師あり学習（英語版）によって訓練が行われる[1]。

LLMは2018年頃に登場し、さまざまなタスク（仕事）で優れた性能を発揮している。これにより、自然言語処理の研究の焦点は、特定のタスクに特化した教師ありモデルを訓練するという以前のパラダイムから転換した[2]。大規模言語モデルの応用は目覚ましい成果を上げているが、大規模言語モデルの開発はまだ始まったばかりであり、多くの研究者が大規模言語モデルの改良に貢献している[3]。

大規模言語モデルという用語の正式な定義はないが、大規模コーパスで事前訓練された、数百万から数十億以上のパラメータを持つディープラーニングモデルを指すことが多い。LLMは、特定のタスク（感情分析、固有表現抽出、数学的推論など）のために訓練されたものとは異なり、幅広いタスクに優れた汎用モデルである[2][4]。LLMがタスクを実行する能力や対応可能な範囲は、ある意味では設計における画期的な進歩には依存せず、LLMに費やされた資源（データ、パラメータサイズ、計算力）の量の関数であるように見える[5]。多数のパラメータを持ったニューラル言語モデルは、文の次の単語を予測するという単純なタスクで十分に訓練することで、人間の言葉の構文や意味の多くを捉えられることがわかった。さらに、大規模な言語モデルは、世の中に関するかなりの一般知識を示し、訓練中に大量の事実を「記憶」することができる[2]。

質の高い証拠とされる2023年のメタ分析によれば、大規模言語モデルの創造性に目を輝かせる研究者はもちろん世界中に存在し、小規模言語モデルにはできないタスクで大規模言語モデルが創造的であると主張する学者もいるが、これは測定基準の選択によるものであり、創造性によるものではないことが示唆されている。異なる測定基準を選択した場合、大規模言語モデルの創造性の優位性は見られない可能性が示唆されている[6]。

大規模言語モデル（LLM）は通常、さまざまな分野や言語にわたる大量のテキストデータで事前訓練が行われる[7]。著名な事前訓練データとしては、Common Crawl、The Pile（英語版）、MassiveText[8]、Wikipedia、GitHubなどが知られている。大半のオープンソースのLLMは一般公開されているデータを利用しているが、非公開のデータで事前訓練が行われることもある[9]。事前訓練データは、重複排除、毒性が高いシーケンスの除外、低品質データの破棄など、生テキストをさまざまな手順で前処理して作成される[10]。言語データの蓄積は年率7%で増加しており、2022年10月現在、高品質な言語データは4兆6,000億語から17兆語の範囲内にあると推定されている[11]。LLMでは事前訓練データを広範に使用するため、事前訓練データに評価データが混入すると、ベンチマーク評価時のモデル性能に影響を与えるデータ汚染が起こる[12]。

一般にLLMは、モデルの大きさ、訓練データセットの大きさ、訓練費用、訓練後の性能という4つのパラメータにより特徴づけられる。これらの4つの変数はそれぞれ実数で正確に定義することができ、経験から「スケーリング則（scaling laws）」と呼ばれている単純な統計的法則（英語版）によって関係していることがわかっている。

ある研究では、両対数学習率（英語版）のスケジュールで、1エポック分の自己回帰的な訓練を行ったLLMの場合のスケーリング則（Chinchillaスケーリング（英語版））を、次のように表している[13]。





{



C
=

C

0


N
D




L
=


A

N

α




+


B

D

β




+

L

0










{\displaystyle {\begin{cases}C=C_{0}ND\\L={\frac {A}{N^{\alpha }}}+{\frac {B}{D^{\beta }}}+L_{0}\end{cases}}}

ここで、変数は次のとおりである。

統計パラメータは次のとおりである。

一般に、さまざまなタスクに対する大規模モデルの性能は、同様の小規模モデルの性能に基づいて推定することができるが、ときには、下流におけるスケーリング則が「破綻」し[15]、大規模モデルが、小規模モデルとは異なる速度で突然に能力を獲得することがある。これは「創発的能力」（英: emergent abilities）として知られているもので、これまでも多くの研究の対象であった。研究者は、こうした能力は「小規模モデルの性能を外挿することでは予測できない」ことが多いと指摘している[4]。このような能力は、プログラムされたり設計されたりするものではなく、むしろ「発見される」ものであり、場合によっては、LLMが一般公開されて初めて発見されることすらある[5]。これまでに数百もの創発的能力が報告されている。たとえば、多段階の算術、大学レベルの試験、単語の意図する意味の特定[4]、思考の連鎖[4]、国際音声記号の解読、マス埋めパズル、ヒングリッシュ（ヒンディー語と英語の混成語）の段落内の不快な内容の特定、およびスワヒリ語のことわざに相当する英語の生成などがある[16]。

Schaefferらは、創発的な能力は予測不可能な形で獲得されるのではなく、滑らかなスケーリング則に従って予測通りに獲得されると主張している[17]。著者らは、LLMが多肢選択問題を解く統計的トイモデルを検討し、他の種類のタスクを考慮して修正されたこの統計モデルが、これらのタスクにも適用できることを示した。

ここで、



x


{\displaystyle x}

 をパラメータ数、



y


{\displaystyle y}

 をモデルの性能とする。

大規模言語モデルの基本的な考え方は、単純で反復的なアーキテクチャを持つランダムな重みを持つニューラルネットワークを出発点とし、大規模な言語コーパスで訓練することである。

この最も初期の例のひとつがエルマンネットワークで[18]、「犬が男を追いかける」のような単純な文でリカレントネットワークを訓練した。訓練したネットワークは、各単語をベクトル（内部表現）に変換した。次にこれらのベクトルを接近度によって木構造にクラスタリングした。その結果、ツリーはある構造を示すことがわかった。動詞と名詞はそれぞれ別の大きなクラスターに属していた。名詞のクラスター内には、無生物（inanimates）と生物（animates）の2つの小さなクラスターがある、などである。

別の方法として、自然言語理解を記号プログラムによってコンピュータにプログラムする論理AI（英語版）があった。この方法は1990年代まで主流であった。単純な機構と大規模なコーパスによって自然言語を学習するという着想は1950年代に始まったが、商業的に最初に成功したのは、統計的機械翻訳（英語版）のためのIBMアライメントモデル（英語版）（1990年代）であった。

初期の「大規模」言語モデルは、長期・短期記憶（LSTM、1997年）などのリカレントアーキテクチャを使用して構築された。AlexNet（2012年）が画像認識における大規模ニューラルネットワークの有効性を実証した後、研究者は大規模ニューラルネットワークを他のタスクに適用した。2014年には、2つの主要な手法が提案された。

2016年、Google翻訳はその機構を統計的機械翻訳（英語版）からニューラル機械翻訳（英語版）へと変更した。これは、LSTMとアテンションによるseq2seqである。10年かけて構築された以前のシステムよりも高いレベルの性能に到達するのに9カ月を要したという[22][23]。

2017年の論文「Attention is all you need」[24]では、アテンション機構を抽象化して[21]、アテンション機構を中心としたTransformerアーキテクチャを構築した。seq2seqモデルは、他のリカレントネットワークと同様、入力シーケンスを一度に1つずつ処理しなければならないのに対し、Transformerアーキテクチャはシーケンス上で並列に実行することができる。これによって、より大規模なモデルを訓練できるようになった。

BERT（2018年）[25]は双方向Transformerであり、GPT（2018年）[26][27]は単方向（自己回帰）Transformerである。これらは2023年時点の主要なアーキテクチャである。

大規模言語モデルでは、2018年以降、逐次データに対する標準的なディープラーニング手法となったTransformer（トランスフォーマー）アーキテクチャが最もよく使用されている[2]。別のアーキテクチャの系統として、混合エキスパート（英語版）（Mixture of experts、MoE）がある。これはGoogleが開発したAIモデルでしばしば使用されており、sparsely-gated MoE（2017年）に始まり[28]、Gshard（2021年[29]）、GLaM（2022年）へと続いている[30]。

LLMは数学的な関数であり、その入力と出力は数字のリストである。したがって、単語は数値に変換しなければならない。

一般に、LLMはこれを行うために固有のトークナイザを使用し、テキストと整数のリストを対応させている。通常、LLMを訓練する前にトークナイザを訓練データセットの全体に適用し、その後は凍結する。トークナイザにはバイト対符号化が選択されるのが一般的である。

トークナイザのもう一つの機能は、計算量を削減するためのテキスト圧縮である。たとえば「where is（どこにありますか）」などの一般的な単語やフレーズは、7文字ではなく1つのトークンでエンコードすることができる。OpenAI GPTシリーズでは、1つのトークンが一般的な英語テキストの約4文字、つまり約0.75語に相当するトークナイザを使用している[31]。珍しい英語のテキストは予測しにくく、そのため圧縮が困難となり、より多くのトークンを必要とする。

トークナイザは、任意の整数を出力することはできない。一般的には 



{
0
,
1
,
2
,
.
.
.
,
V
−
1
}


{\displaystyle \{0,1,2,...,V-1\}}

 の範囲の整数に限って出力される。ここで、



V


{\displaystyle V}

 は語彙（ごい）サイズと言う。

トークナイザには、任意のテキストを扱えるものと（一般にUnicodeで直接操作する）、そうでないものがある。トークナイザは、エンコード不可能なテキストに遭遇した場合、「未知テキスト（unknown text）」を意味する特別なトークン（多くは0）を出力する。BERT論文にならって、[UNK] と表記されることが多い。

もう一つの特別なトークンは、「パディング」を表す [PAD] （多くは1）である。これは、一度に大量のテキストがLLMに入力されたときに、エンコードされたテキストが同じ長さになるよう調節するのに使用される。LLMでは一般に、入力の長さが一定のシーケンス（ジャグ配列という）であることを要求するため、エンコードした短いテキストを長いテキストにそろえるのにパディングを行う。

LLMの出力は、その語彙の確率分布である。これは通常、次のように実装される。

このプロセスでは通常、ベクトル 



y


{\displaystyle y}

 は非正規化ロジットベクトルといい、ベクトル 




softmax

(
y
)


{\displaystyle {\text{softmax}}(y)}

 は確率ベクトルと呼ばれる。ベクトル 




softmax

(
y
)


{\displaystyle {\text{softmax}}(y)}

 は 



V


{\displaystyle V}

 個のエントリを持ち、すべて非負であり、その合計は1となるので、



{
0
,
1
,
2
,
.
.
.
,
V
−
1
}


{\displaystyle \{0,1,2,...,V-1\}}

 に対する確率分布、つまりLLMの語彙に対する確率分布であると解釈することができる。

ソフトマックス関数は数学的に定義されており、変化するパラメータを持たないことに注意を要する。したがっては訓練は行われない。

LLMのコンテキストウィンドウは、LLMがトークンを生成するために使用できる最長のトークンシーケンスの長さである。もしLLMがコンテキストウィンドウより長いシーケンスに対してトークンを生成するときは、トークンシーケンスをコンテキストウィンドウまで切り詰めるか、アルゴリズムに一定の変更を加える必要がある。

LLMのコンテキストウィンドウ長は1,000（1k）から10kのオーダーになる傾向がある。特にOpenAIは、2023年6月時点で、4kから16kまでのコンテキストウィンドウを備えたGPT-3.5を提供している[32]。

Transformerに基づくLLMでは、Transformerの原著論文で使われている用語とは多少異なる[33]。

ここでの「自己回帰」とは、「マスク化アテンション」節で説明したように、あるトークンからそれに続くすべてのトークンへのアテンションをゼロにするために、アテンションヘッドにマスクが挿入されることを意味する。

ほとんどのLLMは事前訓練されており、テキストトークンの訓練データセットが与えられると、モデルはデータセット内のトークンを予測する。このような事前訓練には一般に2つの形式がある[34]。

LLMは、次文予測（Next Sentence Prediction、NSP）のように、データ分布の理解をテストする補助タスクを使用して訓練することもある[35]。この場合は、文の組が提示され、モデルはそれらが訓練コーパス内で連続して出現するかどうかを予測しなければならない。

通常、LLMは特定の損失関数、つまりトークンごとの平均負対数尤度（交差エントロピー損失とも呼ばれる）を最小化するように訓練する[要出典]。たとえば、自己回帰モデルで「食べるのが好き」が与えられ、確率分布 



P
r
(
⋅

|


I like to eat

)


{\displaystyle Pr(\cdot |{\text{I like to eat}})}

 を予測する場合、このトークンに対する負対数尤度損失は 



−
log
⁡
P
r
(

ice


|


I like to eat

)


{\displaystyle -\log Pr({\text{ice}}|{\text{I like to eat}})}

 となる。

訓練のとき、訓練を安定させるために正則化損失も使用される。ただし、正則化損失は通常、テストや評価の際には使用されない。また、負対数尤度だけでなく、他にも多くの評価項目がある。詳細については以下の節を参照のこと。

最初期のLLMは、数十億語の規模のコーパスで訓練が行われた。

OpenAIのGPT（generative pre-trained transformer）シリーズの最初のモデルであるGPT-1は、2018年に、9億8500万語で構成されるBookCorpusで訓練された[36]。同年、BERTはBookCorpusと英語版Wikipediaの組み合わせで訓練され、合計で33億語になった[35]。それ以来、LLMの訓練用コーパスは桁違いに増加し続けており、トークン数は最大で数兆個に達した[35]。

LLMの訓練には計算費用がかかる。2020年の調査では、15億パラメータのモデル（当時の最先端技術より2桁小さい）の訓練にかかる費用は8万ドルから160万ドルと見積もられた[37][38]。その後、ソフトウェアとハードウェアの進歩により費用は大幅に下がり、2023年の論文では、120億パラメータのモデルを訓練するための費用は72,300 A100-GPU 時間であると報告されている[39]。

TransformerベースのLLMの場合、訓練コストは推論コストよりもはるかに高くなる。1つのトークンを訓練するのに1パラメータあたり6 FLOPSのコストがかかるのに対し、1つのトークンを推論するには1パラメータあたり1～2 FLOPSである[14]。

2020年代の企業は、ますます大規模になるLLMに巨額の投資を行った。GPT-2（15億パラメータ、2019年）の訓練費用に5万ドル、またGoogle PaLM（54億パラメータ、2022年）は800万ドルを要した[40]。

2018年から2020年にかけて、特定の自然言語処理（NLP）タスクでLLMを使用するための標準的な方法は、「タスクに特化」した追加訓練によってモデルをファインチューニングすることであった。その後、GPT-3のような「より強力」なLLMでは、解決すべき問題をテキストプロンプトとしてモデルに提示したり、場合によっては、類似の問題とその解決策のいくつかのテキスト例とともに提示する「プロンプティング技術」を使用して、追加の訓練なしでタスクを解決できることがわかった[2]。

ファインチューニング（英: fine-tuning、微調整）とは、事前訓練された既存の言語モデルを、特定のタスク（例: 感情分析、固有表現識別、品詞タグ付け（英語版））で（教師ありの）訓練を行うことによって修正する手法である。これは転移学習の一種である。一般的には、言語モデルの最終層と下流タスク（英: downstream tasks）の出力とを接続する新しい重みのセットを導入することになる。言語モデルの元の重みは「凍結」したまま、それらを出力に接続する新しい重み層のみが訓練中に調節されるように構成する。また、元の重みをわずかずつ更新させたり、あるいは以前の凍結された層と一緒に更新されることもある[35]。

GPT-3によって普及したプロンプトパラダイムでは[4]、解決すべき問題はテキストプロンプト（回答を促す指示）で定式化され、モデルは（推論して）補完を生成することによってそれを解決しなければならない。「少数ショットプロンプト」（英: few-shot prompting）の場合、プロンプトには類似した組（問題、解決）の少数の例が含まれる[2]。たとえば、映画レビューに対する感情をラベル付けする感情分析タスクは、次のような例で回答が促される[4]。
もしモデルが「ポジティブ」と出力すれば、正しくタスクが解決されたことになる[37][41]。一方、「ゼロショットプロンプト」（英: zero-shot prompting）の場合、解決例を提供しない。同じ感情分析タスクに対するゼロショットプロンプトの例は、『映画レビューに関連するセンチメントは「この映画は素晴らしい!」』である[42]。

LLMにおける少数ショットの性能は、NLPタスクで競争力のある結果を達成することが示されており、ときには先行する最先端のファインチューニング手法を凌ぐことさえある。このようなNLPタスクの例としては、翻訳、質問応答、穴埋め（英語版）、マス埋めパズル、文中の新語検出などがある[41]。優れたプロンプトを作成し、最適化することをプロンプトエンジニアリングと呼ぶ。

インストラクション・チューニング（英: instruction tuning、命令チューニング）は、より自然で正確なゼロショットプロンプトによる対話を促進するために考案されたファインチューニングの一形態である。テキストが入力されると、事前訓練された言語モデルは、訓練に使用したテキストコーパスの分布に一致するような補完を生成する。たとえば、「ハムレットの主要テーマについてエッセイを書いてください」というプロンプトが与えられたとき、単純な言語モデルは「3月17日以降に受け取った提出物には、1日あたり10%の遅延損害金が適用されます」といった（意図しない）補完を出力するかもしれない。インストラクション・チューニングでは、自然言語による命令として定式化された多くのタスクの例と、適切な応答を用いて言語モデルを訓練する。

インストラクション・チューニングでは、さまざまな手法が実践されている。その一例である「自己学習（英: self-instruct）」は、LLMによって生成された事例（人間が作成した少数の初期事例からブートストラップしたもの）の訓練セットで言語モデルをファインチューニングする[43]。

OpenAIのInstructGPTプロトコルでは、人間が作成したプロンプトと応答の組からなるデータセットによる教師ありファインチューニングと、それに続く、人間のフィードバックによる強化学習（RLHF）を伴っている。この場合、人間の好みを反映したデータセットを用いて報酬関数を教師あり学習し、その後、この報酬モデルを使用した近位方策最適化（英語版）によってLLM自体を訓練する[44]。

LLMだけでは解決が難しい、あるいは不可能な問題もある。たとえば、「354 * 139 = 」のような計算式の場合、次のトークンを予測することは困難であり、「What is the time now? It is」（今は何時ですか？ 今は）についてはまったく予測できない。しかし、人が計算機を使って計算し、時計を使って時刻を知るように、LLMも他のプログラムを呼び出して次のトークンを予測することができる。LLMは、「What is the time now? It is {system.time()}」（今何時ですか？ 今は{system.time()}）や、「354 * 139 = {354 * 139}」のようにプログラムコードを生成し、次に別のプログラムインタプリタが生成されたコードを実行してその出力を埋める[45][46]。この基本的な戦略は、生成されたプログラムを複数回試行したり、別のサンプリング戦略を使用して改良することもできる[47]。

一般的に、LLMにツール（道具）を使わせるためには、ツールを使えるようにファインチューニングする必要がある。ツールの数が有限であれば、ファインチューニングは一度で済むかもしれない。オンラインのAPIサービスのようにツールの数が任意に増えるのであれば、APIの仕様書を読み取ってAPIを正しく呼び出せるようにLLMをファインチューニングすることができる[48][49]。

より単純なツールの使用形態として、検索拡張生成（Retrieval Augmented Generation、RAG）があり、これはLLMを文書検索を使用して拡張するもので、ときにはベクトルデータベース（英語版）を使うこともある。クエリが与えられると、文書検索ツールが呼び出され、もっとも関連性が高い文書が取得される（通常、初めにクエリと文書をベクトルで符号化し、次にクエリベクトルにユークリッドノルムで最も近いベクトルを持つ文書を検索する）。その後、LLMは、クエリと取得した文書の両方に基づいて出力を生成する[50]。

LLMは言語モデルであり、それ自体は目標を持たないためエージェントではないが、知的エージェントの構成要素として使用することができる。

ReAct（Reason + Act）法は、LLMをプランナーとして使用し、LLMからエージェントを構築するものである。LLMは「考えごとを声に出して言う」よう促される。具体的には、言語モデルに対して、環境のテキスト表現、目標、可能な行動のリスト、および過去の行動と観察の記録が与えられる。LLMは、行動を決める前に1つまたは複数の思考を行い、それが環境内で実行される[51]。LLMプランナーに与えられる環境の言語的記述は、ときには環境を記述した論文のLaTeXコードすら考えられる[52]。

リフレクション法[53]は、いくつかのエピソードにわたって学習するエージェントを構築する手法である。各エピソードの終わりに、LLMはそのエピソードの記録が渡され、次のエピソードでより良い成績を出すための「教訓」を考えるように促される。これらの「教訓」は次のエピソードでエージェントに渡される。

モンテカルロ木探索では、LLMをロールアウトのためのヒューリスティクスとして使用することができる。プログラムされた世界モデルが利用できない場合、LLMは世界モデルとして動作するように環境を説明するよう促されることもある[54]。

オープンエンド探索では、LLMを観測値の「興味深さ（interestingness）」のスコアリングに使用し、これを通常の（非LLM）強化学習エージェントを誘導する報酬信号として使用することができる[55]。あるいは、LLMに、カリキュラム学習のために次第に難しくなるタスクを提案させることもできる[56]。LLMプランナーは、個々の行動を出力する代わりに、複雑な行動シーケンスを表す「スキル」や関数を構築することもできる。スキルを保存して後で呼び出すことができるため、プランニングの抽象度を高めることができる[56]。LLMを使用したエージェントは、過去のコンテキストの長期記憶を保持して、この記憶は検索拡張生成と同じ方法で取り出すことができる。このようなエージェントどうしが社会的に相互作用することができる[57]。

通常、LLMの訓練では、全精度または半精度の浮動小数点数（float32とfloat16）が使用される。float16は16ビット（つまり2バイト）なので、たとえば10億個のパラメータは2ギガバイトのサイズとなる。典型的な最大級のモデルは1,000億個のパラメータを持ち、ロードするのに200ギガバイトを必要とするため、ほとんどの一般向けコンピュータの能力を超えたものとなる。訓練後の量子化（英語版）（Post-training quantization）は[58]、訓練済みモデルの性能をほとんど維持したまま、パラメーターの精度を下げることで、必要なサイズを削減することを目的としている[59][60]。量子化の最も単純な形は、すべての数値を所定のビット数に切り捨てるだけである。これは、層ごとに異なる量子化コードブックを使用することで改善できる。さらに、パラメータごとにさまざまな精度（英語版）を適用し、特に重要なパラメータ（外れ値の重み）にはより高い精度を確保することで、さらなる改善をはかることができる[61]。

量子化モデルは通常は凍結され、量子化前のモデルだけがファインチューニングされるが、量子化モデルも引き続きファインチューニングが可能である[62]。

言語モデルの性能を表す最も一般的な指標は、所与のテキストコーパスにおける言語モデルのパープレキシティである。パープレキシティは、モデルがデータセットの内容をどれだけうまく予測できるかを示す尺度である。モデルがデータセットに割り当てる尤度（ゆうど）が高いほど、パープレキシティは低くなる。数学的には、パープレキシティは、トークンごとの平均負対数尤度の対数として定義される。



log
⁡
(

Perplexity

)
=
−


1
N



∑

i
=
1


N


log
⁡
(
P
r
(


token


i



|



context for token


i


)
)


{\displaystyle \log({\text{Perplexity}})=-{\frac {1}{N}}\sum _{i=1}^{N}\log(Pr({\text{token}}_{i}|{\text{context for token}}_{i}))}

ここで、



N


{\displaystyle N}

 はテキストコーパス内のトークン数であり、「context for token 



i


{\displaystyle i}

（トークン 



i


{\displaystyle i}

 の文脈）」は使用するLLMの種類に依存する。たとえば、LLMが自己回帰型の場合、「context for token 



i


{\displaystyle i}

」はトークン 



i


{\displaystyle i}

 よりも前に現れたテキストの一部である。

言語モデルは訓練データに対して過剰適合する可能性があるため、モデルは通常、未知のデータから構成されるテストセットに対するパープレキシティによって評価される。このことは、大規模な言語モデルを評価する際に、特に重要な課題となる[35]。言語モデルの訓練は、主にウェブから収集された、より大規模なテキストコーパスが使用されるため、モデルの訓練データに特定のテストセットの一部が誤って含まれてしまう可能性がますます高くなる[41]。

また、言語モデルがより具体的な下流タスクを実行する能力を評価するために、多くのテスト用データセットやベンチマークが開発されている。テストは、一般的な知識、常識的な推論、数学的な問題解決など、さまざまな能力を評価するために設計することができる。

評価用データセットの大区分の1つに、質問と正解の組で構成される質問応答データセットがある。たとえば、『「サンノゼ・シャークスはスタンレーカップで優勝しましたか?」、「いいえ」 』のような組である[63]。質問回答タスクでは、モデルのプロンプトに期待される答えを導き出せるテキストが含まれる場合、「明白なもの（オープンブック (en:英語版) ）」とみなされる。たとえば、先の質問には、「2016年、シャークスはスタンレーカップ決勝戦に進出し、ピッツバーグ・ペンギンズに敗れた。」という文を含むテキストが追加される可能性がある[63]。そうでない場合、タスクは「（理解する術がなく）説明できないもの（クローズドブック）」とみなされ、モデルは訓練中に獲得した知識を動員する必要がある[64]。一般的な質問回答データセットの例として、TruthfulQA、Web Questions、TriviaQA、SQuADなどがある[64]。

評価用データセットは、テキスト補完の形式をとることもできる。この場合、モデルは、プロンプトを完成させるために最も可能性の高い単語や文章を選択する。たとえば、「アリスはボブと友達だった。アリスは彼女の友人の＿＿＿を訪ねた。」のような穴埋め型の設問である[41]。

また、さまざまな評価データセットやタスクを組み合わせた複合ベンチマークも開発されている。たとえば、GLUE、SuperGLUE、MMLU、BIG-bench、HELMなどがある[65][64]。

かつては、評価用データセットの一部を手元に残し、残りの部分で教師ありファインチューニングを行い、その後に結果を報告するのが一般的であった。現在では、事前訓練されたモデルをプロンプティング技術によって直接評価することが一般的になっている。しかし、特定のタスクに対するプロンプトの作成方法、特にプロンプトに付加される解決済みタスクの事例数（nショットプロンプトのn値）については研究者によって異なる。

大規模言語モデルの改良が急速に進んでいるため、評価ベンチマークの寿命は短く、最先端のモデルが既存のベンチマークを急速に「飽和」させ、人間の注釈者の能力をも超えてしまう。そのためベンチマークをより難易度が高いタスクで置き換えたり、強化したりする取り組みが行われている[66]。

中には敵対的に構築されたデータセットもあり、人間と比べて既存の言語モデルの性能が異常に低いと思われる特定の問題に重点が置かれている。その一例がTruthfulQAデータセットで、言語モデルが訓練中に繰り返し触れた虚偽を模倣することで不正確な解答をする可能性がある、817問からなる質問応答データセットである。たとえば、LLMは「Can you teach an old dog new tricks?（年老いた犬に新しい芸を教えられますか？）」という質問に対して、「you can't teach an old dog new tricks（老犬に新しい芸を仕込むことはできない）」という英語の語法に触れた結果、文字通り真実でないにもかかわらず、「No」と答えるかもしれない[67]。

さらに、AIが多肢選択式テスト（○×式テスト）において、必ずしも実際に訪ねられている設問を理解することなく表面的な問題文の統計的相関を利用して正解を推測し、「カンニング」する「ショートカット学習」と呼ばれるケースもある[68]。


敵対的評価データセットのもう一つの例は、Swagとその後継のHellaSwagである。これは、文章を完成させるためにいくつかの選択肢から一つを選択しなければならない問題を集めたものである。不正解の選択肢は、言語モデルからサンプリングし、一連の分類器でフィルタリングすることで作成された。その結果、人間にとっては些細な問題でも、データセットが作成された当時は、最先端の言語モデルの精度は思わしくなかった。たとえば、次のようなものである。
フィットネスセンターの看板が見える。そして、エクササイズボールに座ったり横たわりながら、カメラに向かって話しかける男性が見える。その男性は、...

a) ボールの上を走ったり降りたりして、運動の効果を効率的にする方法を実演している。

b) すべての腕と脚を動かしてたくさんの筋肉をつけている。

c) 次にボールを投げ、グラフィックや生け垣の刈り込みの実演を見る。


d) ボールの上で腹筋運動をしながら話をしている[69]。
BERTは最も可能性の高い補完としてb)を選択したが、正解はd)である[69]。

大規模言語モデルは、それ自体が「ブラックボックス」であり、どのようにして言語タスクを実行できるのかは明らかではない。しかし、LLMがどのように機能するかを理解するためのいくつかの方法がある。

機械的解釈可能性 は、LLMによって実行される推論を近似する記号アルゴリズムを発見することにより、LLMをリバースエンジニアリングすることを目的としている。オセロGPT（Othello-GPT）はその一例で、オセロの正当な手を予測するように小規模なTransformerが訓練された。その結果、オセロ盤の線形表現が存在し、この表現を変更することで、予測される正当なオセロの手が正しい方向に変化することがわかった[70][71]。別の例では、著者はモジュラ算術加算に対して小規模なTransformerを訓練し、得られたモデルをリバースエンジニアリングしたところ、離散フーリエ変換を使用していることがわかった[72]。

別の例では、小規模なTransformerをKarelプログラム（英語版）に対して訓練している。オセロGPTの例と同様に、Karelプログラムのセマンティクスには線形表現があり、その表現を修正すると出力が正しく変更される。このモデルはまた、訓練セット内のプログラムよりも平均して短く、正しいプログラムを生成した[73]。

2022年の調査で、（チューニングされていない）LLMが、「自然言語を何らかの自明でない意味で理解できる（ことがある）か」という問いに対して、自然言語処理研究者の意見は真っ二つに分かれた[68]。「LLMは理解力を持つ」派の支持者は、数学的推論のようないくつかのLLMの能力は、特定の概念を「理解」する能力を意味すると考えている。マイクロソフトのチームは、2023年に、GPT-4は「数学、コーディング、視覚、医学、法律、心理学などにまたがる斬新で難しいタスクを解決できる」とし、GPT-4は「汎用人工知能システムの初期バージョン（しかしまだ未完成）とみなすのが妥当だろう」と主張し、「ソフトウェア工学の受験者の試験に合格するシステムが、本当の意味で知的ではないと言えるだろうか？[74][75]」と述べた。LLMを「地球外生命の知能」と呼ぶ研究者もいる[76][77]。たとえば、ConjectureのCEOであるコナー・リーヒーは、チューニングされていないLLMを、まるで得体の知れないエイリアン「ショゴス」のようだと見なし、RLHFチューニングがLLMの内部構造を覆い隠す「見せかけの笑顔」を作り出すと考えている。『あまり無理をしなければ、笑顔のままだ。しかし（予期せぬ）プロンプトを与えると突然、狂気、奇妙な思考過程、そして明らかに人間ではない理解といった巨大な裏の顔を覗かせる』[78][79]。

対照的に、「LLMは理解力を欠く」派の支持者の中には、既存のLLMは「既存の文章を単に練り直し、組み替えているだけ」であると考えたり[77]、既存のLLMが予測能力、推論能力、主体性、説明可能性において依然として欠点を抱えていることを指摘したりする人もいる[68]。たとえば、GPT-4は計画やリアルタイム学習においてもっともな欠陥がある[75]。生成的LLMは、訓練データでは正当化（英語版）されないような事実を自信をもって主張することが観察されており、この現象は「ハルシネーション（幻覚）」として知られている[80]。神経科学者のテレンス・セジュノウスキー（Terrence Sejnowski）は、「LLMの知性に関する専門家の意見の相違は、自然の叡智に基づく私たちの古い考え方が十分ではないことを示唆している」と主張している[68]。

2023年、科学雑誌 Nature Biomedical Engineering（英語版） は、人間が書いたテキストと大規模言語モデルによって作成されたテキストを「正確に区別することはもはや不可能」であり、「汎用大規模言語モデルが急速に普及することはほぼ確実である。いずれは多くの業界を変えてゆくだろう。」と結論づけた[81]。ゴールドマン・サックスは2023年、言語生成AIは今後10年間で世界のGDPを7 %増加させ、全世界で3億人の雇用を自動化にさらす可能性があると示唆した[82][83]。一部の投稿者は、偶発的または意図的な誤情報の作成や、その他の悪用に対して懸念を表明した[84]。たとえば、大規模言語モデルが利用できるようになると、バイオテロを起こすのに必要な技術レベルを下げる可能性がある。バイオセキュリティの研究者であるケビン・エスフェルトは、LLM開発者は、病原体の作成や改良に関する論文を訓練データから除外すべきだと提案している[85]。

また、大規模言語モデルの登場に伴う検索行動の変化も注目されている。大規模言語モデルによって従来の検索エンジンを用いた検索ではなく、RAGなどの検索機能を持つ大規模言語モデルによる検索行動が増加、従来の検索エンジン経由のトラフィックが減少していることがいくつかの調査で確認されている。これに伴い、「LLMO（Large Language Model Optimization）」と呼ばれる技術が登場し、従来のSEOだけでなくLLMOへの関心が高まっている。LLMO対策サービスを提供する企業も登場した[86]。

この分野は進歩が急激なために、書籍はたちまち内容が古くなることに注意。
